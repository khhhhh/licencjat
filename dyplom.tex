\documentclass[a4paper,twoside,12pt]{report}
\usepackage{polski}
\usepackage[T1]{fontenc}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{amssymb}
\usepackage{float}
\usepackage{url}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{tabularx}
\usepackage{picture}
\usepackage{upgreek}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{pdfpages}
\usepackage{booktabs,caption}
\usepackage[flushleft]{threeparttable}

\usepackage{pgfplotstable}
\usepackage{pgfplots}
\usepackage{filecontents}

\usepackage{geometry}

\usepackage{pgfplots}
\usepackage{tikz} 
\usepackage{svg}
\usepackage{lipsum}  
% \usepackage{ tabularray}
\usepackage{vcell}
\graphicspath{ {./grafika/} }
\geometry{lmargin=3.5cm, rmargin=2.0cm, tmargin=2.5cm, bmargin=3.5cm}
\linespread{1.5}

\definecolor{lstbackground}{rgb}{0.95, 0.95, 0.95}
\lstset{
  backgroundcolor = \color{lstbackground},
  frame             	= single,
  keywordstyle=\color{blue},  
  basicstyle        	= \linespread{1}\ttfamily,
  columns           	= fullflexible,
  keepspaces=true,
  showstringspaces  = false,
  commentstyle      	= \color{gray}\upshape,
  numbers           	= left,
  numbersep         	= 5pt,
  stepnumber        	= 1,
  captionpos        	= t,
  numberstyle      	= \tiny,
}

\def\crnrs#1{$^\ulcorner#1_\lrcorner$}

\begin{filecontents*}{fpsVerts.data} 
verts,fps
2813,60.77
5626,60
8439,53.24
11252,52.24
14065,50.46
16878,43.46
19691,30.82
22504,30.04
25317,28.54
28130,27.48
30943,23.16
33756,20.08
36569,19.50
39382,16.87
42195,16.30
45008,14.20
47821,12.79
50634,11.90
53447,11.44
\end{filecontents*}


% \begin{filecontents*}{fpstrees.data} 
% 1,60.77
% 2,60
% 3,53.24
% 4,52.24
% 5,50.46
% 6,43.46
% 7,30.82
% 8,30.04
% 9,28.54
% 10,27.48
% 11,23.16
% 13,20.08
% 15,19.50
% 17,16.87
% 19,16.30
% 21,14.20
% 23,12.79
% 25,11.90
% 27,11.44
% \end{filecontents*}

% treść
\begin{document}

\sloppy
\thispagestyle{empty}
\includepdf{stronatytulowa}
\newpage{}

\thispagestyle{empty}
\newpage{}

\tableofcontents{}

\chapter*{Wstęp} 

Rośliny to rozległa grupa organizmów żywych, występujących na większości 
lądów na Ziemi, a także w środowisku wodnym. 
Należą do nich trawy, drzewa, kwiaty, krzewy, paprocie, mchy i wiele innych.
Istnieje około 391.000 gatunków roślin, z których zdecydowana większość,
około 369.000 (94\%), wytwarza nasiona \cite{howmanyplants}. Rośliny można znaleźć na 
całym świecie, na wszystkich kontynentach. Rośliny dostarczają znaczną część 
tlenu na świecie i stanowią podstawę
większości ekosystemów na Ziemi. Tak ważna część świata rzeczywistego
doczekała się opisanego matematycznie modelu i dalszego zastosowania w różnych rodzajach nauki, w
szczególności w informatyce. Modelowanie roślin w informatyce
jest szeroko stosowane w wielu dziedzinach, takich jak gry, przemysł filmowy, 
agrokultura i architektura. Rośliny charakteryzują się złożoną,
zwykle fraktalną strukturą, która jest trudna do modelowania.
Z tego powodu opracowano różne systemy opisywania modeli roślin,
aby uporządkować i uprościć pracę z modelowaniem drzew. Jednym z
takich systemów jest system Lindenmayera, który umożliwia opis struktur 
fraktalnych, w szczególności roślin na poziomie gramatyki formalnej.

\addcontentsline{toc}{chapter}{Wstęp}


% \chapter*{Cel pracy} 

Celem pracy jest zastosowanie i ewaluacja systemu Lindenmayera do generowania 
roślin w aplikacji do planowania przestrzeni zielonych. Specyfikacja programu 
została przygotowana we współpracy z pracownikami Instytutu Nauk Biologicznych 
Uniwersytetu Marii Curie Skłodowskiej w~Lublinie. Oprogramowanie powinno posiadać 
następujące funkcje:

\begin{itemize}
\setlength\itemsep{-0.4em}
\item[-] możliwość wyświetlania drzew w przestrzeni trójwymiarowej,
\item[-] możliwość modyfikowania drzew przy użyciu różnych parametrów,
\item[-] możliwość wyboru tekstur dla pnia drzewa i liści,
\item[-] możliwość symulacji wzrostu drzew,
\item[-] możliwość zapisywania i wczytywania drzew o określonych parametrach.

\end{itemize}


%\addcontentsline{toc}{chapter}{Cel pracy}


\chapter{System Lindenmayera} 


\section{Informacje wstępne}

Systemy Lindenmayera (L-Systemy) zostały wprowadzone i rozwinięte w 1968 roku
 przez Aristida Lindenmayera \cite{modelingOfPlants},
węgierskiego biologa teoretycznego i botanika z~Uniwersytetu w Utrechcie.
Lindenmayer wykorzystał L-systemy do opisu zachowania komórek roślinnych i
modelowania procesów wzrostu w rozwoju roślin.

Reguły L-systemu reprezentują rekurencję.
Prowadzi to do samopodobieństwa, a~więc formy fraktalne można łatwo opisać za pomocą L-Systemu.
Modele roślin, komórek i innych form organicznych naturalnie występujących gatunków można łatwo zdefiniować za pomocą L-systemu,
ponieważ wraz ze wzrostem poziomu rekurencji forma powoli "rośnie" i staje się coraz bardziej złożona.
Systemy Lindenmayera są również popularne w symulowaniu sztucznego życia \cite{neuralStructures}.

Na rysunku \ref{fig:lsystreeexample} jest przykład zastosowania L-systemu dla stworzenia 
fraktalnej struktury, która przypomina drzewo.


\begin{figure}[H]
	\centering\includegraphics[height=7cm]{grafika/treefirst}
	\caption{Przykład stworzonej struktury za pomocą L-systemu}
    \label{fig:lsystreeexample}
\end{figure}

\section{Struktura L-systemu}


L-systemy są obecnie powszechnie nazywane parametrycznymi L-systemami, definiowanymi jako krotka:

\begin{gather}
	G = (V, \omega, P),
\end{gather}
gdzie

\begin{itemize}
	\item[-] V (alfabet) -- to zbiór symboli zawierający zarówno elementy, które można zastąpić (zmienne), jak i te, których nie można zastąpić ("stałe" lub "terminale"),
	\item[-] \(\omega\) (początek, aksjomat lub inicjator) -- to ciąg symboli z V, który określa stan początkowy systemu,
	\item[-] P  -- to zbiór reguł produkcji lub produktów określających sposób zastępowania zmiennych przez kombinacje stałych i innych zmiennych. Produkcja składa się z dwóch ciągów: poprzednika i następnika. Dla każdego symbolu A, który jest członkiem zbioru V i~nie występuje po lewej stronie żadnego iloczynu w P, zakłada się tożsamość iloczynu A → A; symbole te nazywamy stałymi lub terminalnymi.
\end{itemize}

W standardowej wersji L-systemów reguły wnioskowania są następujące:
\begin{gather}
	v \rightarrow \omega,
\end{gather}
gdzie $v$ jest znakiem danego alfabetu $V$, $\omega \in V^* $ jest łańcuchem
znaków (ewentualnie pustym) w tym samym alfabecie.
Każdą regułę można więc interpretować jako
podział komórki $(|\omega| > 1)$, lub jej modyfikację $(|\omega| = 1)$, lub
jako jej śmierć $(|\omega| = 0)$.

Na tabeli \ref{tab:table1} przedstawiono przykład L-systemu.
\begin{table}[H]
	\caption{Przykład stworzonej struktury za pomocą L-systemu}
	\label{tab:table1}
	\begin{center}
		\begin{tabular}{|c|c|l|}
			\hline
			Alfabet & Aksjomat & 
			\multicolumn{1}{c|}{Reguły} \\ [0.5ex]
			\hline
			\{ \crnrs{A}, \crnrs{B}, \crnrs{F}, \crnrs{H},\crnrs{J},\crnrs{+}, \crnrs{-} \} &
			\crnrs{FB}                            &
			\crnrs{A} $\rightarrow$ \crnrs{FBFA+FB-FA} \\
			& & \crnrs{B} \(\rightarrow\) \crnrs{FB+FA-FB-J} \\
			& & \crnrs{F} \(\rightarrow\) \crnrs{} \\
			& & \crnrs{H} \(\rightarrow\) \crnrs{-} \\
			& & \crnrs{J} \(\rightarrow\) \crnrs{+}                                            \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Po zdefiniowaniu L-systemu, zaczyna ona ewoluować zgodnie ze swoimi zasadami. 
Stanem początkowym L-systemu jest jego aksjomat. 
Wraz z dalszym rozwojem ta linia opisująca stan ulegnie zmianie. 
Rozwój L-systemu odbywa się cyklicznie. W każdym cyklu rozwoju ciąg 
jest oglądany od początku do końca, symbol po symbolu. 
Dla każdego znaku wyszukiwana jest reguła, dla której ten znak 
jest poprzednikiem. Jeśli taka reguła nie zostanie znaleziona,
znak jest pozostawiony bez zmian. Innymi słowy, dla tych znaków \crnrs{X},
dla których nie istnieje reguła jawna, obowiązuje reguła domyślna: \crnrs{X} $\rightarrow$ \crnrs{X}.
Jeśli zostanie znaleziona pasująca reguła, znak poprzednika jest
zastępowany przez łańcuch następnika z tej reguły.

Dla ilustracji rozważmy następujący L-system
(nazywamy go glon (łac. \textit{algæ}), ponieważ jego rozwój
 modeluje wzrost pewnego gatunku alg) w tabeli \ref{tab:table2}:

\begin{table}[H]
	\caption{Przykład stworzonej struktury za pomocą L-systemu}
	\label{tab:table2}
	\begin{center}
		\begin{tabular}{|c|c|l|}
			\hline
			Aksjomat & Reguły \\ [0.5ex]
			\hline
			\crnrs{A} & 
			\crnrs{A} $\rightarrow$ \crnrs{B} \\

			& \crnrs{B} $\rightarrow$ \crnrs{AB} \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

W tabeli \ref{tab:table3} przedstawiono stany tego L-systemu
odpowiadające pierwszym dziesięciu cyklom rozwoju systemu.

\begin{table}[H]
	\caption{Wyniki L-systemu z tabeli \ref{tab:table2} od zera do ośmiu iteracji }
	\label{tab:table3}
	\begin{center}
		\begin{tabular}{|c|l|}
			\hline
			Generacja & Stan \\ [0.5ex]
			\hline
			0 & \crnrs{A} \\
			1 & \crnrs{B} \\
			2 & \crnrs{AB} \\
			3 & \crnrs{BAB} \\
			4 & \crnrs{ABBAB} \\
			5 & \crnrs{BABABBAB} \\
			6 & \crnrs{ABBABBABABBAB} \\
			7 & \crnrs{BABABBABABBABBABABBAB} \\
			8 & \crnrs{ABBABBABABBABBABABBABABBABBABABBAB} \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Można zauważyć, że długości ciągów kodujących stan takiego L-systemu tworzą ciąg liczb Fibonacciego,
czyli ciąg liczbowy, w którym każda liczba jest równa sumie dwóch
poprzednich. Ciągami Fibonacciego będą także numery znaków A i B
w tych ciągach. Bardziej zaskakujący jest fakt, że ciąg ciągów ma
taką samą prawidłowość jak ciąg liczb Fibonacciego: każdy ciąg jest sumą
(konkatenacją) dwóch poprzednich.

Aby uzyskać stan L-systemu po określonej liczbie iteracji, 
napisałem funkcję (listing \ref{lst:lsystemfunc}), do której można wstawić aksjomat, 
zbiór reguł L-systemu oraz liczbę iteracji. 
Funkcja zwraca stan łańcucha po podanej liczbie iteracji.

\begin{lstlisting}[language=Python, caption={Funkcja, która zwraca stan systemu po określonej liczbie iteracji}, label={lst:lsystemfunc}]
def iter(axiom: str, rules: dict, iterations: int) -> str:
	if iterations == 0: return axiom
	returnString = ''
	for i in axiom:
		if i in rules:
			returnString += rules[i]
		else:
			returnString += i
	return iter(returnString, rules, iterations-1)
\end{lstlisting}


\section{Interpretacja ciągu znaków}

W celu dalszej graficznej interpretacji otrzymanych ciągów
należy wprowadzić pojęcie grafiki żółwia. Grafika żółwia
to zasada organizacji graficznej biblioteki wyjściowej oparta 
na metaforze żółwia, wyimaginowanego 
(a w niektórych eksperymentach rzeczywistego) urządzenia 
przypominającego robota, które porusza się po ekranie 
lub papierze i obraca w zadanym kierunku, 
pozostawiając za sobą (lub opcjonalnie nie pozostawiając) 
narysowaną linię o zadanym kolorze i grubości.
Nawiązanie do żółwia inspirowane jest powstałym w latach 60. 
językiem Logo, służącym do nauki programowania, 
który wykorzystywał grafikę żółwia jako dwuwymiarowy kursor.


Interpretacja znaków polega na zdefiniowaniu operacji dla symboli
(nie jest konieczne dla wszystkich) w alfabecie. Czynności, podobnie 
jak symbole, są z kolei definiowane
przez autora systemu. Rysunek \ref{fig:interpret} przedstawia przykład interpretacji
symbolu (z kątem $\alpha = 90^\circ$ ) w następujący sposób:

\begin{itemize}
	\item[-] \crnrs{F} oznacza przejście do przodu i narysuj linię,
	\item[-] \crnrs{-} oznacza obrót w kierunku przeciwnym do ruchu wskazówek zegara na kąt o~mierze $\alpha$,
	\item[-] \crnrs{+} oznacza obrót zgodnie z ruchem wskazówek zegara o $\alpha$.
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\draw [ultra thick, ->] (3,0) -- (3,3);
			\draw [thick, dashed, ->] (3,0) -- (0,0);
			\draw [thick, dashed, ->] (3,0) -- (6,0);
			\draw [thick, dotted, ->] (3,1.5) to [out=180, in=90] (1.5,0);
			\draw [thick, dotted, ->] (3,1.5) to [out=0, in=90] (4.5,0);
			\draw [fill] (3,0) circle [radius=0.1];
			\node [above] at (2.5,0.5) {-$\alpha$};
			\node [above] at (3.5,0.5) {$\alpha$};
			\node [below] at (1.5, 2.5) {\textbf{\crnrs{-}}};
			\node [below] at (4.5, 2.5) {\textbf{\crnrs{+}}};
			\node [above] at (3,3) {\textbf{\crnrs{F}}};
			\node [left] at (0,0) {\textbf{\crnrs{-F}}};
			\node [right] at (6,0) {\textbf{\crnrs{+F}}};
			\node [below] at (3,-0.1) {\textbf{$O$}};
		\end{tikzpicture}
	\end{center}
	\caption{Przykładowa interpretacja symboli}
	\label{fig:interpret}
\end{figure}


Zdefiniujemy również zbiór reguł L-systemu w tabeli \ref{tab:table4}.
Łącząc zestaw reguł z interpretacją symboli z rysunku \ref{fig:interpret}, 
otrzymujemy strukturę rekurencyjną zwaną krzywą smoka (tabela \ref{tab:table5}). 

Widać, że po każdej iteracji struktura staje się coraz bardziej
złożona. Wynik piętnastu iteracji pokazano na rysunku \ref{fig:dragoncurve}.

\begin{table}[H]
	\caption{Zestaw reguł L-system dla krzywej smoka (ang. \textit{dragon curve})}
	\begin{center}
		\begin{tabular}{|c|c|l|}
			\hline
			Alfabet & Aksjomat & 
			\multicolumn{1}{c|}{Reguły} \\ [0.5ex]
			\hline
			\{   \crnrs{F}, \crnrs{X},\crnrs{Y} \} &
			\crnrs{FB}                            &
			\crnrs{A} $\rightarrow$ \crnrs{FBFA+HFA+FB-FA} \\
			& & \crnrs{B} \(\rightarrow\) \crnrs{FB+FA-FB-JFBFA} \\
			& & \crnrs{F} \(\rightarrow\) \crnrs{} \\
			& & \crnrs{H} \(\rightarrow\) \crnrs{-} \\
			& & \crnrs{J} \(\rightarrow\) \crnrs{+}                                            \\
			\hline
		\end{tabular}
	\end{center}
	\label{tab:table4}
\end{table}


\begin{table}[H]
	\caption{Krzywa smoka w iteracji 1-7}
	\label{tab:table5}
		\centering
		\begin{tabular}{|c|c|}
			\hline
			Iteracji & Stan \\ [0.5ex]
			\hline
			1 &  \begin{tabular}[c]{@{}c@{}}\includegraphics[scale=0.6]{grafika/example1}\\\end{tabular} \\
			\hline
			2 & \begin{tabular}[c]{@{}c@{}}\includegraphics[scale=0.6]{grafika/example2}\\\end{tabular} \\
			\hline
			3 & \begin{tabular}[c]{@{}c@{}}\includegraphics[scale=0.6]{grafika/example3}\\\end{tabular} \\
			\hline
			4 & \begin{tabular}[c]{@{}c@{}}\includegraphics[scale=0.6]{grafika/example4}\\\end{tabular} \\
			\hline
			5 & \begin{tabular}[c]{@{}c@{}}\includegraphics[scale=0.6]{grafika/example5}\\\end{tabular} \\
			\hline
			6 & \begin{tabular}[c]{@{}c@{}}\includegraphics[scale=0.6]{grafika/example6}\\\end{tabular} \\
			\hline
			7 & \begin{tabular}[c]{@{}c@{}}\includegraphics[scale=0.6]{grafika/example7}\\\end{tabular} \\
			\hline
		\end{tabular}
\end{table}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{grafika/example152}
	\caption{Wynik piętnastu iteracji krzywej smoka}
	\label{fig:dragoncurve}
\end{figure}

W przykładzie krzywej smoka (rysunek \ref{fig:dragoncurve}) żółw zawsze
porusza się o tę samą odległość, a jego linie mają tę samą grubość.
Jednak w świecie rzeczywistym rośliny
i~drzewa mają zasadniczo strukturę rozgałęzioną. W strukturze fraktalnej
roślin każda pojedyncza gałąź może być przedstawiona jako osobna roślina,
choć w zredukowanej formie. Dlatego, aby symulować drzewa, do L-systemu 
należy dodać parametry długości i grubości linii utworzonej przez 
żółwia. 

Kolejny zestaw reguł (tabela \ref{tab:rulesTree}) demonstruje przykład tworzenia struktury 
przypominającej drzewo \cite{beautyofplants}.
W przykładzie tego L-systemu do alfabetu wprowadzane są~nowe znaki. 
Ich interpretacja przez żółwia jest następująca:

\begin{itemize}
	\setlength\itemsep{1em}
	\item[-] \crnrs{[} oznacza ``zapisać bieżący stan żółwia do stosu'',
	\item[-] \crnrs{]} oznacza ``odczytać bieżący stan żółwia do stosu'',
	\item[-] \crnrs{X} jest ignorowany przez żółwia.
\end{itemize}

W przykładzie przedstawionym w książce \cite{beautyofplants} grubość linii narysowanej
przez żółwia nie zmienia się. Rozszerzyłem przykład z podręcznika
i dodałem czynnik grubości, przez który będzie mnożona grubość 
w zależności od zagnieżdżenia gałęzi. 

W wyniku zastosowania wszystkich powyższych reguł powstaje 
struktura przypominająca drzewo (rysunek \ref{fig:treeExample})


\begin{table}[H]
	\caption{Zestaw reguł L-system dla przykładowego drzewa}
	\begin{center}
		\begin{tabular}{|c|c|l|l|}
			\hline
			Alfabet & Aksjomat & 
			\multicolumn{1}{c|}{Reguły} &
			\multicolumn{1}{c|}{Konstanty} \\ [0.5ex]
			\hline
			\{   \crnrs{F}, \crnrs{X}, \crnrs{[}, \crnrs{]} \} & 
			\crnrs{X}                            &
			\crnrs{X} $\rightarrow$ \crnrs{F[+X]F[-X]+X} &
			Kąt powrotu = $20^\circ$ \\
			& & \crnrs{F} $\rightarrow$ \crnrs{F} & 
			Grubość linii = 6px \\
			& & & Czynnik grubości = 0.5 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tab:rulesTree}
\end{table}


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{grafika/treeExample}
	\caption{Utworzona struktura na podstawie reguł z tabeli \ref{tab:rulesTree}}
	\label{fig:treeExample}
\end{figure}


% Również, w przypadku zdefiniowanych reguł l-systemu w tabeli \ref{tab:table4}, 
% zastosowanie powyższych reguł daje za każdym razem taki sam wynik.
% Jednak w świecie rzeczywistym prawie niemożliwe jest napotkanie dwóch
% identycznych struktur fraktalnych. Wiele czynników świata 
% rzeczywistego ma wpływ na końcowy rezultat każdej konstrukcji. 
% Dlatego, aby symulować prawdziwe rośliny, musimy dodać do l-systemu 
% losowość.  

\subsection{Trójwymiarowe generowanie drzew}

Aby utworzyć trójwymiarowe drzewa, należy zdefiniować symbole dla żółwia, 
który będzie odpowiedzialny za obroty w przestrzeni trójwymiarowej. 
Jednym ze sposobów byłoby zdefiniowanie obrotów żółwia na każdej osi (X, Y, Z), 
a także możliwość ustawienia kąta obrotu. Dzięki temu żółw może poruszać się we 
wszystkich możliwych kierunkach. Podczas budowania drzewa, w momencie gdy gałąź 
się rozgałęzia, należy, podobnie jak w przypadku 2D, ustawić kąty dla każdej z 
nowych gałęzi. Lindenmayer sugeruje użycie trzech wektorów 
do reprezentowania kierunku żółwia (przód, lewo i~góra) \cite{beautyofplants}.

W tym przypadku obroty żółwia będą reprezentowane przez 
następujące równanie:

\begin{gather}
	\left[ \; \overrightarrow{H}' \; \overrightarrow{L}' \; \overrightarrow{U}' \; \right] 
	= \left[ \; \overrightarrow{H} \; \overrightarrow{L} \;  \overrightarrow{U} \; \right] R,
\end{gather}

gdzie 
\begin{itemize}
	\item[-] H jest wektorem wskazującym górę żółwia, 
	\item[-] L jest wektorem wskazującym lewą stronę żółwia, 
	\item[-] F jest wektorem wskazującym przód żółwia,
	\item[-] R jest macierzą trójwymiarową.
\end{itemize}
Macierz R, w zależności od osi obrotu, 
może wyglądać w następujący sposób:

\begin{gather}
	R_{H}(\alpha) =  
	\begin{bmatrix}
		1 & 0 & 0 \\
		0 & \cos{\alpha} & -\sin{\alpha}   \\
		0 & \sin{\alpha} & \cos{\alpha}  
	\end{bmatrix},
\end{gather}

\begin{gather}
	R_{L}(\alpha) =  
	\begin{bmatrix}
		\cos{\alpha} & 0 & -\sin{\alpha}   \\
		0 & 1 & 0 \\
		\sin{\alpha} & 0 &  \cos{\alpha}
	\end{bmatrix},
\end{gather}

\begin{gather}
	R_{U}(\alpha) =  
	\begin{bmatrix}
		\cos{\alpha} & \sin{\alpha} & 0   \\
		-\sin{\alpha} & \cos{\alpha} &  0 \\
		0 & 0 & 1
	\end{bmatrix}.
\end{gather}



\chapter{Implementacja} 

W zakresie implementacji stworzyłem oprogramowanie, które pozwala na 
wizualizację przyległego terenu do nieruchomości w trójwymiarowej 
przestrzeni, na której można umieścić drzewa. Drzewa można 
zmieniać za pomocą różnych parametrów i symulować ich wzrost.

\section{Wykorzystane narzędzia}

\subsection{Język i zintegrowane środowisko programistyczne}

Do stworzenia programu wykorzystałem język programowania 
C++ w standardzie 17. Użyłem Qt Creator w wersji 6.0.1 jako 
zintegrowanego środowiska programistycznego.

Stworzone oprogramowanie wykorzystuje język C++ dla całej logiki aplikacji.

\subsection{Biblioteka Proctree}

Proctree.js to biblioteka dla języka programowania JavaScript, 
która pozwala na~tworzenie drzewa jako siatki wierzchołków \cite{proctreejs}.
Biblioteka posiada dużą liczbę parametrów, które wpływają na 
ostateczny wynik drzewa. Autorem biblioteki jest brytyjski 
programista Paul Brunt. Później fiński programista Jari Komppa 
zrobił port tej biblioteki dla C++. Biblioteka w wersji C++ jest szybsza \cite{proctree}.

Biblioteka Proctree jest głównym narzędziem do tworzenia siatki wierzchołków,
normalnych i mapowania UV dla drzewa w programie.


\subsection{Biblioteka Nlohmann JSON}

Nlohmann JSON to biblioteka do obsługi danych formatu JSON \cite{nlohmannjson}.
Biblioteka ma wiele zalet: intuicyjna syntaktyka, łatwa integracja,
wydajność pamięci, szybkość. Autorem biblioteki jest 
niemiecki programista Niels Lohmann.

Biblioteka Nlohmann JSON jest używana w programie do zapisywania i 
ładowania parametrów drzewa w postaci pliku JSON.

\subsection{OpenGL}

OpenGL jest specyfikacją definiującą niezależny od
platformy interfejs programowania aplikacji do pisania 
aplikacji wykorzystujących grafikę komputerową 2D i 3D. 
Twórcą jest amerykańska firma Silicon Graphics. OpenGL pozwala na tworzenie 
złożonych scen 3D za pomocą prymitywów. Wykorzystuje do tego zasoby 
karty graficznej. Wykorzystywany jest do 
tworzenia gier komputerowych, wirtualnej rzeczywistości.

Powstałe oprogramowanie wykorzystuje OpenGL do renderowania trójwymiarowej 
przestrzeni i drzew. Zostało przetestowane w wersji OpenGL 3.3.

\section{Funkcjonalność aplikacji}

Stworzone oprogramowanie posiada szereg funkcji, które pozwalają na 
zaprojektowanie rozmieszczenia drzew w otoczeniu przy budynku. 

Na rysunku \ref{fig:screenmainwindow} można zaobserwować główne okno programu. 
Konwencjonalnie okno główne można podzielić na dwa obszary -- 
obszar ustawień i obszar roboczy.

Część ustawień znajduje się po lewej i dolnej stronie okna. 
Obszar roboczy zajmuje większość okna i znajduje się po prawej stronie okna.

Obszar ustawień obejmuje:
\begin{enumerate}[label=\arabic*)]
	\item suwak do regulacji drzew,
	\item suwak do zmiany wieku drzewa,
	\item lista utworzonych drzew,
	\item przycisk symulacji wzrostu drzew,
	\item przycisk do zmiany tekstur,
	\item pasek menu.
\end{enumerate}

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/main2.png}
	\caption{Główne okno programu}
    \label{fig:screenmainwindow}
\end{figure}

Obszar roboczy to trójwymiarowa przestrzeń, która symuluje obszar 
wokół budynku drzewa. Kamerę można przesuwać za pomocą klawiatury. 
Klawisze W, A, S, D służą do poruszania się odpowiednio do przodu, 
w lewo, do tyłu i w prawo. Klawisz Q służy do poruszania się wyżej. 
Aby obniżyć kamerę niżej, użyj klawisza Z. 
Kamerę można obracać za pomocą myszy z wciśniętym lewym przyciskiem.  


\subsection{Planowanie rozmieszczenia drzew}

Aby posadzić drzewa, najpierw za pomocą myszy i klawiatury 
ustawiamy kamerę tak, aby widoczny był obszar, w którym chcemy 
posadzić drzewko (rysunek \ref{fig:placeTree}). Następnie umieszczamy kursor w miejscu, w którym 
chcemy posadzić drzewo i klikamy prawym przyciskiem myszy (rysunek \ref{fig:placeTree2}).


\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/placeTree.png}
	\caption{Okno programu przed posadzeniem drzewa}
    \label{fig:placeTree}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/placeTree2.png}
	\caption{Okno programu po posadzeniu drzewa}
    \label{fig:placeTree2}
\end{figure}

Nie ma ograniczeń co do liczby drzew w programie, 
ale należy pamiętać, że duża liczba drzew może wpłynąć na wydajność, 
a w szczególności na symulację wzrostu. Rysunek \ref{fig:50trees} pokazuje 
50 posadzonych drzew.

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/50trees.png}
	\caption{50 posadzonych drzew}
    \label{fig:50trees}
\end{figure}

\subsection{Symulacja wzrostu}

Na potrzeby demonstracji ustawiłem trzy drzewa i 
zmieniłem ich parametry, aby były różne (rysunek \ref{fig:beforeGrow}).

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/beforeGrow.png}
	\caption{Trzy różnych drzewa}
    \label{fig:beforeGrow}
\end{figure}

Symulacja wzrostu może odbywać się na dwa sposoby: 
ręcznie, poprzez ustawienie ``wieku'' drzewa (rysunek \ref{fig:oneTree}, \ref{fig:percentGrow}), 
oraz automatycznie, poprzez naciśnięcie przycisku ``Rosnąć'' \textit{(ang. Grow)} (rysunek \ref{fig:growAll}). 
Każda z tych metod ma dwa tryby: zmiana wzrostu pojedynczego 
wybranego drzewa (rysunek \ref{fig:oneTree}) lub zmiana wzrostu wszystkich drzew (rysunki \ref{fig:percentGrow}, \ref{fig:growAll}). 
Tryb jest przełączany za pomocą przycisku wyboru ``Wszystkie drzewa'' \textit{(ang. All trees)}. 

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/oneTreeGrow.png}
	\caption{Ręczna zmiana wzrostu jednego drzewa}
    \label{fig:oneTree}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/percentGrow.png}
	\caption{Ręczna zmiana wzrostu wszystkich drzew}
    \label{fig:percentGrow}
\end{figure}


\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/AllGrow.png}
	\caption{Automatyczny wzrost drzew}
    \label{fig:growAll}
\end{figure}

Liczba drzew wpływa na to, jak szybko będą generowane. 
Dzieje się tak dlatego, że~każde drzewo jest generowane inaczej, 
biorąc pod uwagę to, jak będzie wyglądało pod koniec wzrostu.
Nie udało mi się tego zoptymalizować.

Podczas zmiany wzrostu można również poruszać kamerą, 
ale ponieważ proces wzrostu wymaga dość dużej wydajności, 
kamera może poruszać się wolniej.

\subsection{Ustawianie parametrów}

Parametry w moim programie pozwalają na manipulowanie wyglądem. 
W efekcie mogą powstawać różne rodzaje drzew. 
Każdy z parametrów wpływa na określone cechy drzew. 
W moim programie występują następujące rodzaje parametrów:

\begin{itemize}
\setlength\itemsep{1em}
	\item[-] ziarno \textit{(ang. seed)} to parametr odpowiedzialny za generator drzewa pseudolosowego,
	\item[-] poziomy \textit{(ang. levels)} to parametr odpowiadający za liczbę rozgałęzień głównych gałęzi (które wyrastają z pnia) drzewa (rysunek \ref{fig:levels}),
	\item[-] stopnie drzew \textit{(ang. tree steps)} to parametr odpowiadający za liczbę gałęzi drzewa (pnia) (rysunek \ref{fig:treeSteps}),
	\item[-] współczynnik gałęzi \textit{(ang. branch factor)} to parametr wpływający na kąt rozgałęzienia wszystkich gałęzi z wyjątkiem gałęzi głównych,
	\item[-] tempo wznoszenia \textit{(ang. climb rate)} to parametr odpowiedzialny za długość pnia po miejscach, w których następuje rozgałęzienie (rysunek \ref{fig:climbRate}),
	\item[-] kępa minimalna \textit{(ang. clump min)} i kępa maksymalna \textit{(ang. clump max)} to parametry związane wpływające na rozprzestrzenianie się wzrostu gałęzi drzew,
	\item[-] wartość opadania \textit{(ang. drop amount)} to parametr wpływający na siłę ciężkości na gałęziach drzewa (rysunek \ref{fig:dropAmount}),
	\item[-] tempo wzrostu \textit{(ang. grow amount)} to parametr wpływający na siłę grawitacji dla głównych gałęzi drzewa,
	\item[-] początkowa długość gałęzi \textit{(ang. initial branch length)} to parametr odpowiedzialny za początkową długość głównych gałęzi (ponieważ kolejne gałęzie pobierają procent długości z gałęzi nadrzędnej, ma to wpływ na wszystkie gałęzie) (rysunek \ref{fig:initBranchLen}),
	\item[-] współczynnik zmniejszania długości \textit{(ang. length fall off factor)} i moc zmniejszania długości \textit{(ang. length fall off power)} to parametry związane wpływające na~długość wszystkich gałęzi,
	\item[-] maksymalny promień \textit{(ang. max radius)} parametr określający promień drzewa (dotyczy zarówno gałęzi jak i pnia),
	\item[-] spadek promienia \textit{(ang. radius falloff)} to parametr określający grubość gałęzi po rozgałęzieniu (gałęzie pobierają pewien procent grubości gałęzi macierzystej, parametr ten ustala ten procent),
	\item[-] zamiatanie \textit{(ang. sweep)} to parametr, który wpływa na ogólny kierunek wszystkich gałęzi. Tworzy efekt podobny do tego, jak drzewo jest pod wpływem wiatru,
	\item[-] stożek \textit{(ang. taper)} to parametr wpływający na stosunek grubości gałęzi na początku do końca (przy wyższych parametrach gałąź zaczyna przypominać stożek),
	\item[-] wygięcie pnia \textit{(ang. trunk kink)} to parametr wpływający na krzywiznę pnia w miejscach, gdzie on się rozgałęzia,
	\item[-] długość pnia \textit{(ang. trunk length)} to parametr wpływający na długość pnia (dotyczy tylko części pnia przed pierwszą gałęzią) (rysunek \ref{fig:trunkLen}),
	\item[-] skala gałęzi \textit{(ang. twig scale)} to parametr, który wpływa na wielkość gałązek,
	\item[-] skrętność \textit{(ang. twist rate)} to parametr odpowiadający za skręt pnia,
	\item[-] mnożnik \textit{(ang. Vmultiplier)} to parametr wpływający na rozciąganie tekstury,
	\item[-] sezon \textit{(ang. season)} to parametr, który wpływa na kolor liści drzewa (rysunek \ref{fig:season}).
\end{itemize}


\begin{figure}[H]
	\centering\includegraphics[width=10cm]{grafika/params/Levels.png}
	\caption{Zmiana parametru levels: po lewej 1, po prawej 7, w zakresie od 1 do 7}
    \label{fig:levels}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=9cm]{grafika/params/TreeSteps.png}
	\caption{Zmiana parametru tree steps: po lewej 1, po prawej 10, w zakresie od 1 do 10}
    \label{fig:treeSteps}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=10cm]{grafika/params/ClimbRate.png}
	\caption{Zmiana parametru climb rate: po lewej 90, po prawej 1, w zakresie od 1 do 100}
    \label{fig:climbRate}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=10cm]{grafika/params/DropAmount.png}
	\caption{Zmiana parametru drop amount: po lewej -69, po prawej 70, w zakresie od -90 do 90}
    \label{fig:dropAmount}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=10cm]{grafika/params/InitBranchLen.png}
	\caption{Zmiana parametru initial branch length: po lewej 19, po prawej 100, w zakresie od 1 do 100}
    \label{fig:initBranchLen}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=10cm]{grafika/params/TrunkLen.png}
	\caption{Zmiana parametru trunk length: po lewej 10, po prawej 50, w zakresie od 1 do 100}
    \label{fig:trunkLen}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=10cm]{grafika/params/Season.png}
	\caption{Zmiana parametru season: po lewej 1, po prawej 9, w zakresie od 1 do 9}
    \label{fig:season}
\end{figure}

\subsection{Ustawianie tekstur}

Moje oprogramowanie pozwala również na zmianę tekstur. 
Można zmienić teksturę pnia drzewa, gałęzi drzewa i fasady budynku.
Użytkownik może wybrać tekstury, które chce zastosować. 

Aby zmienić teksturę pnia i gałęzi drzewa, program odczytuje pliki 
znajdujące się w folderze \textit{textures/} w korzeniu programu. 
Folder \textit{textures/twigs/} zawiera tekstury gałęzi, 
a folder \textit{textures/trees/} zawiera tekstury pnia.
Po dodaniu tekstur do tego folderu, po uruchomieniu programu i 
naciśnięciu przycisku wybierz teksture \textit{(ang. select texture)} 
otwiera okno wyboru tekstury (rysunek \ref{fig:texchoosewin}), w którym 
można wybrać teksturę gałęzi i pnia drzewa z listy wszystkich tekstur 
znajdujących się w wyżej wymienionych folderach.

\begin{figure}[ht]
	\centering\includegraphics[width=12cm]{grafika/program/texture2.png}
	\caption{Okno wyboru tekstury}
    \label{fig:texchoosewin}
\end{figure}

Po wybraniu tekstur i potwierdzeniu przyciskiem OK, 
tekstury drzew zostają zmienione na wybrane 
tekstury (rysunek \ref{fig:texchoosewin2}).

\begin{figure}[H]
	\centering\includegraphics[width=12cm]{grafika/program/texture3.png}
	\caption{Zmienione tekstury drzewa}
    \label{fig:texchoosewin2}
\end{figure}

Aby zmienić teksturę budynku należy wybrać w pasku menu plik 
\textit{(ang. file)}, a~następnie kliknąć na otworzyć 
teksturę budynku \textit{(ang. open building texture)} (rysunek \ref{fig:choosebuild}).
Następnie zostanie otwarte okno wyboru pliku systemu operacyjnego. 
Za~pomocą tego okna wybieramy plik, który ma być użyty 
jako tekstura i naciśkamy przycisk OK. 
Spowoduje to zmianę tekstury budynku (rysunek \ref{fig:choosebuild2}).

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/texture4.png}
	\caption{Zmiana tekstury budynku}
    \label{fig:choosebuild}
\end{figure}

\begin{figure}[ht]
	\centering\includegraphics[width=15.5cm]{grafika/program/texture5.png}
	\caption{Zmieniona tekstura budynku}
    \label{fig:choosebuild2}
\end{figure}

\subsection{Zapis do pliku}

W moim programie istnieje możliwość zapisania konfiguracji drzewa do pliku. 
Funkcja ta pozwala na zapisanie utworzonych drzew, aby można je było 
wykorzystać później. Aby to zrobić, trzeba będzie 
załadować wcześniej zapisaną konfigurację z pliku.
Sam plik jest plikiem JSON (listing \ref{lst:treeFile}), w którym zapisane są wszystkie parametry.

\begin{lstlisting}[caption={Zawartość pliku drzewa}, label={lst:treeFile}]
{
    "mBranchFactor": 2.45,
    "mClimbRate": 0.37,
	...
    "mTwistRate": 3.019,
    "mVMultiplier": 0.36
}
\end{lstlisting}

Aby zapisać wybrane drzewo, w menu pasku wybierz opcję Zapisz 
jako \textit{(ang. Save as)} (rysunek \ref{fig:saveTree}) lub naciśnąć kombinację klawiszy Ctrl+Shift+S. 
Następnie należy wybrać katalog, w którym ma być zapisany plik, 
wpisać jego nazwę i kliknąć przycisk Zapisz.

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/program/saveTree.png}
	\caption{Opcja zapisu drzewa do pliku}
    \label{fig:saveTree}
\end{figure}


\section{Struktura programu}

Struktura pozwala zademonstrować główne części programu, 
które wchodzą ze sobą w interakcje. Na rysunku \ref{fig:classDiagram} 
przedstawiono diagram klas utworzony w języku opisu graficznego UML. 
Większość pól klasy prywatnej posiada settery i gettery, 
ale dla uproszczenia nie są one pokazane na diagramie. 
Główne klasy w programie to:
\begin{itemize}
	\item[-] MainWindow ta klasa jest główną klasą programu, opisuje logikę dla wszystkich komponentów okna programu, jak również wszystkie interakcje programu,
	\item[-] OpenGlWidget to klasa opisująca logikę renderowania przestrzeni trójwymiarowej,
	\item[-] Tree to klasa, która reprezentuje drzewa w programie. Klasa ta przechowuje logikę zmiany wzrostu drzewa, parametry, a także dwa obiekty klasy mesh - dla pnia i~gałęzi drzewa oraz liści,
	\item[-] Mesh to klasa przechowująca wszystkie dane do budowy obiektów trójwymiarowych w środowisku opengl (wierzchołki, krawędzie, normale i mapy UV).
\end{itemize}

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/diagrams/class}
	\caption{Diagram klasy}
    \label{fig:classDiagram}
\end{figure}

W celu zademonstrowania głównej funkcji programu 
(symulacja wzrostu drzew), wykonałem dwa diagramy: 
\begin{itemize}[noitemsep,topsep=0pt]
	\item[-] diagram procesu w celu przedstawienia logiki wzrostu drzew (rysunek \ref{fig:flowDiagram}),
	\item[-] diagram sekwencyjny mający na celu zademonstrowanie współdziałania obiektów klas programu (rysunek \ref{fig:sequenceDiagram}).
\end{itemize}

Na diagramie sekwencji widać, jak obiekt klasy 
MainWindow otrzymuje informację o tym, 
że użytkownik nacisnął przycisk Grow. 
Po tym zdarzeniu obiekt mainWindow przechodzi przez 
każdy obiekt w drzewie i na każdym z nich wywołuje 
metodę growTree. Metoda growTree jest opisana na 
schemacie procesu. Na końcu tej metody wywoływana 
jest metoda generate zewnętrznej biblioteki Proctree, 
której klasa obsługuje generowanie i zwraca obiekt Mesh.
Obiekt Mesh jest później używany do renderowania drzewa 
w oknie OpenGl.

\begin{figure}[H]
	\centering\includegraphics[height=10cm]{grafika/diagrams/flow}
	\caption{Diagram procesu}
    \label{fig:flowDiagram}
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=15.5cm]{grafika/diagrams/sequence}
	\caption{Diagram sekwencji}
    \label{fig:sequenceDiagram}
\end{figure}

\chapter{Testy i rezultaty}

Po stworzeniu, ręcznie przetestowałem stworzony program, 
aby sprawdzić operatywność i wydajność programu. 
Testy zostały przeprowadzone na laptopie o 
następujących konfiguracjach:
\begin{itemize}
	\item[-] system operacyjny Windows 10,
	\item[-] procesor centralny AMD Ryzen 5 5600H 3.30 Ghz,
	\item[-] karta graficzna NVIDIA GeForce GTX 1650,
	\item[-] pamięć główna 16 GB. 
\end{itemize}

Dzięki opracowaniu programu w środowisku Qt, 
program jest cross-platformowy i~nie jest przywiązany 
do konkretnego systemu operacyjnego, sprzętu. 
Ponadto, aby zainstalować oprogramowanie wystarczy 
rozpakować archiwum z oprogramowaniem w~dowolnym miejscu 
na dysku twardym. Program wykorzystuje ścieżki względne, 
dzięki czemu może pracować z dowolnego folderu 
na dysku twardym. Cechy te są istotne ze~Względu na plan 
udostępnienia aplikacji szerszemu gronu odbiorców.

Testowanie programu odbywało się w trakcie tworzenia programu, 
jak również testowania ostatecznej wersji programu. 

Testy wszystkich funkcjonalności dały pozytywny wynik, 
a wszystkie funkcje programu działają zgodnie z pierwotnymi 
warunkami. 

Jednakże, w trakcie testów wydajności wykryto błąd krytyczny, 
który nie był związany z funkcjonalnością, ale z 
działaniem programu i polegał na okresowych awariach.  
Tryb debugowania został wykorzystany do próby odkrycia 
przyczyny problemu niespodziewanych awarii programu. 
Okazało się, że błąd objawiał się czasem w momencie, 
gdy OpenGl tworzy i inicjalizuje siatkę buforową. 
Nie było jednak wystarczających informacji o przyczynie awarii, 
aby naprawić problem. 

\section{Wydajność}

Wydajność oprogramowania jest dość mocno uzależniona 
od używanego sprzętu. Na testowanym przeze mnie 
urządzeniu wydajność wzrostu drzew jest bezpośrednio 
związana z liczbą umieszczonych drzew, a także ich 
złożonością. Parametry drzewa, takie jak Levels i Tree steps, 
mają szczególnie duży wpływ na wydajność.
Są to jedyne parametry, które zmieniają liczbę wierzchołków i 
krawędzi drzewa. Wszystkie inne parametry zmieniają jedynie 
położenie wierzchołków. Każde drzewo przy Levels i Tree steps 
ustawionych na 5 ma 2183 węzły i 6045 krawędzi. 
Jeśli jednak ustawimy oba te~parametry na 6, 
to liczba węzłów wzrośnie do 5408 węzłów i 13806 krawendzi. 
Dlatego im więcej poziomów ma drzewo, tym większe będzie obciążenie urządzenia 
i~wolniejsze generowanie drzewa.

Przetestowałem wydajność wzrostu dzrew i zrobiłem wykres 
zależności średniej liczby klatek na sekundę (ang. \textit{FPS}) 
od liczby wierzchołków (rysunek \ref{fig:chart}).

\begin{figure}[H]
	\begin{center}
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={Liczba wierzchołków}, 
				ylabel={Średnia liczba klatek na sekundę},
				xtick={2813,11252,19691,28130,36569,45008,53447},
				ymajorgrids=true,
				grid style=dashed,
				% x tick label style={
				% 	font=\small,
				% 	rotate=90,
				% 	/pgf/number format/.cd,%
				% 	scaled x ticks = false,
				% 	set thousands separator={.},
				% 	fixed
				% }
			]
			% Plot goes here 
			\addplot[black, x=verts, y=fps] table [col sep=comma] {fpsVerts.data};
		\end{axis} 
	\end{tikzpicture}
	\end{center}
	\caption{Wykres zależności średniej liczby klatek na sekundę od licbzy drzew}
	\label{fig:chart}
\end{figure}

\section{Porównanie z innymi rozwiązaniami}

Istnieje jeszcze kilka innych rozwiązań, które generują 
trójwymiarowe drzewa. Oto następujące programy o podobnej 
funkcjonalności do mojego rozwiązania:
\begin{itemize}
	\item[-] Snappytree \cite{snappyTree},
	\item[-] PD: Tree Generator \cite{PDTree},
	\item[-] HappyTree \cite{proctree}. 
\end{itemize}
Snappy tree i PD: Tree Genrator używa biblioteki proctree.js 
jako podstawy, podczas gdy Happy Tree używa portu biblioteki proctree, 
tak jak program, który stworzyłem.
Charakterystyczną cechą mojego programu jest symulacja wzrostu drzew. 
Taka funkcjonalność nie jest dostępna w wymienionych programach.
Przykład obecności lub braku danej cechy przedstawiono w tabeli \ref{tab:compareTable}.


\begin{table}[H]
	\caption{Porównanie możliwości rozwiązań}
	\label{tab:compareTable}
	\small
	\setlength\tabcolsep{2pt}
	\centering
	\begin{center}
		\begin{tabular}{|p{4.4cm}|c|c|c|c|}
			\hline
			& Moje rozwiązanie & PD: Tree Generator & Snappy Tree & Happy Tree \\ [0.5ex]
			\hline
			\begin{tabular}[p{4.4cm}]{@{}p{4.4cm}@{}}
				Ustawienie parametrów generacji drzewa
			\end{tabular}
			& Tak & Tak & Tak & Tak \\ [0.5ex]
			\hline
			\begin{tabular}[p{4.4cm}]{@{}p{4.4cm}@{}}
				Zapis parametrów do pliku JSON
			\end{tabular}
			 & Tak & Tak & Tak & Nie \\ [0.5ex]
			\hline
			\begin{tabular}[p{4.4cm}]{@{}p{4.4cm}@{}}
				Obsługa wielu drzew
			\end{tabular}
			 & Tak & Nie & Nie & Tak$^1$ \\ [0.5ex]
			\hline
			\begin{tabular}[p{4.4cm}]{@{}p{4.4cm}@{}}
				Ładowanie tekstur niestandardowych
			\end{tabular}
			& Tak & Nie & Nie & Nie \\ [0.5ex]
			\hline
			\begin{tabular}[p{4.4cm}]{@{}p{4.4cm}@{}}
				Zapis modelu do pliku OBJ
			\end{tabular}
			 & Nie & Tak & Tak & Tak \\ [0.5ex]
			\hline
			\begin{tabular}[p{4.4cm}]{@{}p{4.4cm}@{}}
				Ustawienie oświetlenia 
			\end{tabular}
			& Nie & Tak & Nie & Nie \\ [0.5ex]
			\hline
		\end{tabular}
		\begin{tablenotes}
			\small
			\item 1 Nie można wpływać na liczbę i lokalizację drzew
		  \end{tablenotes}
	\end{center}
\end{table}

Wiele z alternatywnych rozwiązań zapewnia funkcjonalność, która 
nie została zaimplementowana w moim rozwiązaniu. Jednak 
moje rozwiązanie dostarcza wąsko ukierunkowaną funkcjonalność, 
która została przygotowana we współpracy z pracownikami 
Instytutu Nauk Biologicznych 
Uniwersytetu Marii Curie Skłodowskiej w~Lublinie.

\chapter*{Podsumowanie}

Celem niniejszej pracy było opracowanie oraz 
zastosowane systemu Lindenmaera w~symulacji
wzrostu roślin.

System Lindenmaera jest zbiorem reguł, które pozwalają na 
zdefiniowanie generacji struktur fraktalnych. Pomimo 
swojej prostoty L-system posiada cechy rozszerzalności, 
dzięki czemu możliwe jest opisywanie złożonych struktur, 
w tym roślin świata rzeczywistego \cite{impactsOnTheorCompSci}.

Na wstępie przedstawiono szczegóły dotyczące systemu Lindenmeyera, 
przykłady zastosowania i wyniki w przestrzeni dwuwymiarowej oraz 
opis tworzenia drzew w przestrzeni trójwymiarowej. 
Następnie przedstawiono implementację oprogramowania 
pozwalającego na projektowanie lokalizacji drzew, 
możliwość ich parametryzacji oraz symulację zmian w czasie.
Ostatnim krokiem było przetestowanie stworzonego oprogramowania 
i porównanie go z innymi podobnymi rozwiązaniami.

Wadą przedstawionego rozwiązania jest niestabilność programu, 
która w szczególnych przypadkach objawia się zatrzymaniem programu. 
Ten problem nie został rozwiązany.
Nie ma też symulacji oświetlenia, co mogłoby być dobrym dodatkiem.

\bibliographystyle{ieeetr}
\bibliography{bibliography/bib}
\addcontentsline{toc}{chapter}{Bibliografia}

\end{document}